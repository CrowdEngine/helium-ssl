# The "auto_ssl" shared dict should be defined with enough storage space to
# hold your certificate data. 1MB of storage holds certificates for
# approximately 100 separate domains.
lua_shared_dict auto_ssl 1m;
# The "auto_ssl_settings" shared dict is used to temporarily store various settings
# like the secret used by the hook server on port 8999. Do not change or
# omit it.
lua_shared_dict auto_ssl_settings 64k;

# A DNS resolver must be defined for OCSP stapling to function.
#
# This example uses Google's DNS server. You may want to use your system's
# default DNS servers, which can be found in /etc/resolv.conf. If your network
# is not IPv6 compatible, you may wish to disable IPv6 results by using the
# "ipv6=off" flag (like "resolver 8.8.8.8 ipv6=off").
resolver 8.8.8.8;

# Initial setup tasks.
init_by_lua_block {
  auto_ssl = (require "resty.auto-ssl").new()

  auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")
  {{ $redis_url := var "REDIS_URL" }}
  {{ $redis_url_map := $redis_url | split "@" }}
  {{ $redis_host_map := index $redis_url_map 1 }}
  {{ $redis_host_map := $redis_host_map | split ":" }}
  {{ $redis_host := index $redis_host_map 0 }}
  {{ $redis_port := index $redis_host_map 1 }}
  {{ $redis_auth_map := index $redis_url_map 0 }}
  {{ $redis_auth_map := $redis_auth_map | split ":" }}
  {{ $redis_auth := index $redis_host_map 1 }}
  auto_ssl:set("redis", {
    host = "{{ $redis_host }}",
    port = "{{ $redis_port }}",
    auth = "{{ $redis_auth }}",
    db = 1
  })

  {{ $use_le_staging := var "USE_LE_STAGING" }}
  {{ if eq $use_le_staging "true" }}
  auto_ssl:set("ca", "https://acme-staging-v02.api.letsencrypt.org/directory")
  {{ end }}

  -- Define a function to determine which SNI domains to automatically handle
  -- and register new certificates for. Defaults to not allowing any domains,
  -- so this must be configured.
  auto_ssl:set("allow_domain", function(domain)
    local http = require("resty.http")
    local httpc = http.new()

    httpc:set_timeout(5000)

    local ok, coerr = httpc:connect("unix:{{ var "NODE_PORT" }}")

    if not ok then
      ngx.log(ngx.ERR, err)
      return false
    end

    local path = "/domains/"..domain
    print("Querying API for custom domain: ", path)

    local res, err = httpc:request({
      path = path,
      method = "GET",
      headers = {
        ["Host"] = "localhost",
      }
    })

    if not res then
      print("Failed to request: ", err)
      return false
    end

    if res.status == 200 then
      print("Domain is allowed! Status code: ", res.status, " _id: ", res.body)
      return true
    end

    if res.status == 404 then
      print("Domain not found. Status code: ", res.status)
      return false
    end

    print("Unexpected response from API. Status code: ", res.status)
    return false
  end)

  auto_ssl:init()
}

init_worker_by_lua_block {
  auto_ssl:init_worker()
}

{{ range $port_map := .PROXY_PORT_MAP | split " " }}
{{ $port_map_list := $port_map | split ":" }}
{{ $scheme := index $port_map_list 0 }}
{{ $listen_port := index $port_map_list 1 }}
{{ $upstream_port := index $port_map_list 2 }}

{{ if eq $scheme "http" }}
server {
  listen      [{{ $.NGINX_BIND_ADDRESS_IP6 }}]:{{ $listen_port }};
  listen      {{ if $.NGINX_BIND_ADDRESS_IP4 }}{{ $.NGINX_BIND_ADDRESS_IP4 }}:{{end}}{{ $listen_port }};
  server_name _;
  access_log  {{ $.NGINX_ACCESS_LOG_PATH }};
  error_log   {{ $.NGINX_ERROR_LOG_PATH }};
{{ if (and (eq $listen_port "80") ($.SSL_INUSE)) }}
  location / {
    return 301 https://$host:{{ $.PROXY_SSL_PORT }}$request_uri;
  }
{{ else }}
  location    / {

    gzip on;
    gzip_min_length  1100;
    gzip_buffers  4 32k;
    gzip_types    text/css text/javascript text/xml text/plain text/x-component application/javascript application/x-javascript application/json application/xml  application/rss+xml font/truetype application/x-font-ttf font/opentype application/vnd.ms-fontobject image/svg+xml;
    gzip_vary on;
    gzip_comp_level  6;

    proxy_pass  http://{{ $.APP }}-{{ $upstream_port }};
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;
    proxy_set_header Host $http_host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Request-Start $msec;
  }

  include {{ $.DOKKU_ROOT }}/{{ $.APP }}/nginx.conf.d/*.conf;

  error_page 400 401 402 403 405 406 407 408 409 410 411 412 413 414 415 416 417 418 420 422 423 424 426 428 429 431 444 449 450 451 /400-error.html;
  location /400-error.html {
    root {{ $.DOKKU_LIB_ROOT }}/data/nginx-vhosts/dokku-errors;
    internal;
  }

  error_page 404 /404-error.html;
  location /404-error.html {
    root {{ $.DOKKU_LIB_ROOT }}/data/nginx-vhosts/dokku-errors;
    internal;
  }

  error_page 500 501 502 503 504 505 506 507 508 509 510 511 /500-error.html;
  location /500-error.html {
    root {{ $.DOKKU_LIB_ROOT }}/data/nginx-vhosts/dokku-errors;
    internal;
  }
{{ end }}

  location /.well-known/acme-challenge/ {
    content_by_lua_block {
      auto_ssl:challenge_server()
    }
  }
}
{{ else if eq $scheme "https"}}
server {
  listen      [{{ $.NGINX_BIND_ADDRESS_IP6 }}]:{{ $listen_port }} ssl {{ if eq $.HTTP2_SUPPORTED "true" }}http2{{ else if eq $.SPDY_SUPPORTED "true" }}spdy{{ end }};
  listen      {{ if $.NGINX_BIND_ADDRESS_IP4 }}{{ $.NGINX_BIND_ADDRESS_IP4 }}:{{end}}{{ $listen_port }} ssl {{ if eq $.HTTP2_SUPPORTED "true" }}http2{{ else if eq $.SPDY_SUPPORTED "true" }}spdy{{ end }};
  server_name _;
  access_log  {{ $.NGINX_ACCESS_LOG_PATH }};
  error_log   {{ $.NGINX_ERROR_LOG_PATH }};

  ssl_certificate           {{ $.APP_SSL_PATH }}/server.crt;
  ssl_certificate_key       {{ $.APP_SSL_PATH }}/server.key;
  ssl_protocols             TLSv1.2 {{ if eq $.TLS13_SUPPORTED "true" }}TLSv1.3{{ end }};
  ssl_prefer_server_ciphers off;

  # Dynamic handler for issuing or returning certs for SNI domains.
  ssl_certificate_by_lua_block {
    auto_ssl:ssl_certificate()
  }

  keepalive_timeout   70;
  {{ if and (eq $.SPDY_SUPPORTED "true") (ne $.HTTP2_SUPPORTED "true") }}add_header          Alternate-Protocol  {{ $.PROXY_SSL_PORT }}:npn-spdy/2;{{ end }}

  location    / {

    gzip on;
    gzip_min_length  1100;
    gzip_buffers  4 32k;
    gzip_types    text/css text/javascript text/xml text/plain text/x-component application/javascript application/x-javascript application/json application/xml  application/rss+xml font/truetype application/x-font-ttf font/opentype application/vnd.ms-fontobject image/svg+xml;
    gzip_vary on;
    gzip_comp_level  6;

    proxy_pass  https://app_server;
    {{ if eq $.HTTP2_PUSH_SUPPORTED "true" }}http2_push_preload on; {{ end }}
    proxy_http_version 1.1;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host pham.dev.crowdengine.com;
    proxy_redirect off;
  }
  include {{ $.DOKKU_ROOT }}/{{ $.APP }}/nginx.conf.d/*.conf;

  error_page 400 401 402 403 405 406 407 408 409 410 411 412 413 414 415 416 417 418 420 422 423 424 426 428 429 431 444 449 450 451 /400-error.html;
  location /400-error.html {
    root {{ $.DOKKU_LIB_ROOT }}/data/nginx-vhosts/dokku-errors;
    internal;
  }

  error_page 404 /404-error.html;
  location /404-error.html {
    root {{ $.DOKKU_LIB_ROOT }}/data/nginx-vhosts/dokku-errors;
    internal;
  }

  error_page 500 501 503 504 505 506 507 508 509 510 511 /500-error.html;
  location /500-error.html {
    root {{ $.DOKKU_LIB_ROOT }}/data/nginx-vhosts/dokku-errors;
    internal;
  }

  error_page 502 /502-error.html;
  location /502-error.html {
    root {{ $.DOKKU_LIB_ROOT }}/data/nginx-vhosts/dokku-errors;
    internal;
  }
}
{{ end }}
{{ end }}


# Internal server running on port 8999 for handling certificate tasks.
server {
  listen 127.0.0.1:8999;

  # Increase the body buffer size, to ensure the internal POSTs can always
  # parse the full POST contents into memory.
  client_body_buffer_size 128k;
  client_max_body_size 128k;

  location / {
    content_by_lua_block {
      auto_ssl:hook_server()
    }
  }
}

upstream app_server {
  server {{ var "UPSTREAM_SERVER_URL" }} fail_timeout=0;
}